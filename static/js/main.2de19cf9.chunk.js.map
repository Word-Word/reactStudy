{"version":3,"sources":["index.js"],"names":["Square","props","className","onClick","value","Board","i","this","squares","renderSquare","React","Component","Game","state","history","Array","fill","stepNumber","xIsNext","slice","current","length","console","log","calculateWinner","setState","concat","step","status","winner","moves","map","move","desc","key","jumpTo","handleClick","lines","a","b","c","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.2de19cf9.chunk.js","sourcesContent":["import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\n\n// 실행순서: Game -> Board -> Square 9번 실행\nfunction Square(props) {\n\n    return (\n        \n        <button className=\"square\" onClick={props.onClick}>\n            {props.value}\n        </button>\n    );\n}\n  \nclass Board extends React.Component {\n    renderSquare(i) {\n        // 각 Square에게 현재 값('X', 'O', 또는 null)을 표현하도록 Board를 수정\n        return (\n            <Square\n                value={this.props.squares[i]}\n                onClick={() => this.props.onClick(i)}\n            />\n        );\n    }\n\n    render() {\n      return (\n        <div>\n          <div className=\"board-row\">\n            {this.renderSquare(0)}\n            {this.renderSquare(1)}\n            {this.renderSquare(2)}\n          </div>\n          <div className=\"board-row\">\n            {this.renderSquare(3)}\n            {this.renderSquare(4)}\n            {this.renderSquare(5)}\n          </div>\n          <div className=\"board-row\">\n            {this.renderSquare(6)}\n            {this.renderSquare(7)}\n            {this.renderSquare(8)}\n          </div>\n        </div>\n      );\n    }\n  }\n  \n  class Game extends React.Component {\n    // [과거로 돌아가는 시간여행] 이전 동작에 대한 리스트를 보여주기 위해서는 최상위(Game) 컴포넌트에 history state를 둬야 한다.\n    constructor(props) {\n      super(props);\n      this.state = {\n        history: [ \n          {\n            squares: Array(9).fill(null)\n          }\n        ],\n        stepNumber: 0,\n        xIsNext: true,\n      };\n    }\n\n    // 따로 뺀 함수 (바둑판을 클릭해서 새로운 '입력'이 삽입되야 하는 경우 발동)\n    handleClick(i) {\n      const history = this.state.history.slice(0, this.state.stepNumber + 1);  // 과거로 돌아간 뒤 새로 '입력'이 되었을 경우: '미래'의 기록을 모두 날린다 (0번째 인덱스부터 stepNumber+1까지)\n      const current = history[history.length - 1];\n      const squares = current.squares.slice();  // slice() : current 안에 있는 squares라는 원본 배열의 복사본을 반환 (원본 배열은 수정하지 않음)\n\n      console.log(\"history: \", history);\n      console.log(\"current: \", current);\n      console.log(\"squares: \", squares);      \n      console.log(\"history.length: \", history.length);\n      console.log(\"---------------------------------------\");\n      \n\n      // 누군가 승리하거나 || 이미 그 칸이 채워져 있는 경우 클릭 무시\n      if (calculateWinner(squares) || squares[i]) {\n        return;\n      }\n\n      squares[i] = this.state.xIsNext ? 'X' : 'O';  // xIsNext 값에 따라 X와 O를 결정\n\n      this.setState({\n        history: history.concat([{ squares }]),  // push()는 기존 배열을 수정하고, concat()은 기존 배열을 변경하지 않고 대신 새 배열을 반환\n        xIsNext: !this.state.xIsNext,\n        stepNumber: history.length,  // 과거로 돌아가기 (i번째 턴으로 복귀)\n      });\n    }\n\n    // 과거로 돌아가는 버튼 클릭시 발동\n    jumpTo(step) {\n      this.setState({\n        stepNumber: step,\n        xIsNext: (step % 2) === 0,  // 짝수일 경우 xIsNext를 true로 설정\n      })\n    }\n\n    render() {\n      const history = this.state.history;\n      // const current = history[history.length - 1];\n      const current = history[this.state.stepNumber];  // 항상 마지막 이동을 보여주는 것이 아니라 현재 선택된 이동을 렌더링\n      const winner = calculateWinner(current.squares);\n\n\n      // 과거로 돌아가는 버튼 목록 표시\n      const moves = history.map((step, move) => {\n        const desc = move ?\n          move + \"번째 턴\" :\n          '시작지점';\n\n        return (\n          <li key = {move}>\n            <button onClick={() => this.jumpTo(move)}> {desc} </button>\n          </li>\n        );\n      });\n\n      // * 배열에 map 함수 사용 예시\n      // const numbers = [1, 2, 3];\n      // const doubled = numbers.map(x => x * 2);  // [2, 4, 6] -> 각 배열마다 적용\n      // -----------------------------------------------------------------------\n\n\n      let status;\n      if (winner) {\n        status = 'Winner: ' + winner;\n      } else {\n        status = 'Next player: ' + (this.state.xIsNext ? 'X' : 'O');\n      }\n\n      return (\n        <div className=\"game\">\n          <div className=\"game-board\">\n            <Board \n              squares={ current.squares }\n              onClick={ (i) => this.handleClick(i) }\n            />\n          </div>\n          <div className=\"game-info\">\n            <div> {status} </div>\n            <ol>  {moves}  </ol>\n          </div>\n        </div>\n      );\n    }\n  }\n  \n\n  // ================================================\n  // 승부가 나는 때와 더 이상 둘 곳이 없을 때를 알려주는 도우미 함수\n  function calculateWinner(squares) {\n    const lines = [\n      [0, 1, 2],  // 가로 1줄\n      [3, 4, 5],  // 가로 2줄\n      [6, 7, 8],  // 가로 3줄\n      [0, 3, 6],  // 세로 1줄\n      [1, 4, 7],  // 세로 2줄\n      [2, 5, 8],  // 세로 3줄\n      [0, 4, 8],  // 왼쪽 대각선 1줄\n      [2, 4, 6],  // 우측 대각선 1줄\n    ];\n\n    for (let i = 0; i < lines.length; i++) {\n      const [a, b, c] = lines[i];\n      \n      // 1줄 전체가 OOO, XXX 이렇게 되면 반환\n      if (squares[a] && squares[a] === squares[b] && squares[a] === squares[c]) {\n        return squares[a];  // O 혹은 X를 반환\n      }\n    }\n\n    return null;\n  }\n  // ========================================\n  \n  ReactDOM.render(\n    <Game />,\n    document.getElementById('root')\n  );\n  "],"sourceRoot":""}